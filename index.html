<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Movimiento Parab√≥lico (Proyectiles) - Canvas</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    body { margin: 0; background:#0b0f14; color:#e9eef5; }
    header { padding: 16px 18px; border-bottom: 1px solid #1d2633; }
    h1 { font-size: 18px; margin: 0 0 6px; }
    .wrap { display: grid; grid-template-columns: 360px 1fr; gap: 14px; padding: 14px; }
    .panel { background:#101826; border:1px solid #1d2633; border-radius: 12px; padding: 12px; }
    label { display:block; font-size: 12px; opacity: .9; margin-top: 10px; }
    input[type="range"] { width: 100%; }
    .row { display:flex; gap:10px; align-items:center; }
    .row > div { flex:1; }
    .btns { display:flex; gap:10px; margin-top: 12px; }
    button {
      background:#1f6feb; border:0; color:white; padding:10px 12px; border-radius:10px;
      cursor:pointer; font-weight:600;
    }
    button.secondary { background:#22314a; }
    .stat { font-size: 13px; line-height: 1.4; margin-top: 10px; }
    .canvasWrap { position: relative; }
    canvas { width: 100%; height: calc(100vh - 92px); background:#070a0f; border-radius: 12px; border:1px solid #1d2633; display:block; }
    .overlay {
      position: absolute;
      left: 14px;
      top: 14px;
      background: rgba(16,24,38,0.72);
      border: 1px solid rgba(29,38,51,0.9);
      backdrop-filter: blur(6px);
      border-radius: 12px;
      padding: 10px 10px;
      font-size: 12px;
      line-height: 1.35;
      max-width: 420px;
    }
    .overlay b { font-weight: 700; }
    .overlay .ok { color: #6ee7b7; }
    .overlay .warn { color: #fbbf24; }
    .overlay .bad { color: #f87171; }
    .hint { font-size: 12px; opacity:.8; margin-top: 8px; }
    code { background:#0b1220; padding:2px 6px; border-radius:6px; }
  </style>
</head>
<body>
  <header>
    <h1>Simulador de Movimiento Parab√≥lico (Proyectiles) ‚Äî HTML Canvas + JavaScript</h1>
    <div class="hint">
      Modelo ideal: sin resistencia del aire. Ecuaciones: <code>x(t)=v0¬∑cos(Œ∏)¬∑t</code>,
      <code>y(t)=y0+v0¬∑sin(Œ∏)¬∑t-(1/2)¬∑g¬∑t¬≤</code>
    </div>
  </header>

  <div class="wrap">
    <section class="panel">
      <div class="row">
        <div>
          <label>Velocidad inicial v0 (m/s): <b id="v0Label"></b></label>
          <input id="v0" type="range" min="1" max="40" step="0.5" value="18" />
        </div>
        <div>
          <label>√Ångulo Œ∏ (¬∞): <b id="angLabel"></b></label>
          <input id="ang" type="range" min="1" max="89" step="1" value="40" />
        </div>
      </div>

      <div class="row">
        <div>
          <label>Altura inicial y0 (m): <b id="y0Label"></b></label>
          <input id="y0" type="range" min="0" max="20" step="0.5" value="0" />
        </div>
        <div>
          <label>Gravedad g (m/s¬≤): <b id="gLabel"></b></label>
          <input id="g" type="range" min="1" max="20" step="0.1" value="9.8" />
        </div>
      </div>

      <label>Œît (s) ‚Äî paso de simulaci√≥n: <b id="dtLabel"></b></label>
      <input id="dt" type="range" min="0.005" max="0.05" step="0.005" value="0.016" />

      <div class="btns">
        <button id="playBtn">Simular</button>
        <button id="resetBtn" class="secondary">Reset</button>
      </div>

      <div class="stat" id="stats"></div>

      <div class="hint">
        Para la exposici√≥n: comparen esta simulaci√≥n num√©rica (por frames) con el modelo anal√≠tico.
        Es lo mismo que hace un motor de f√≠sica: integra movimiento con <code>Œît</code>.
      </div>
    </section>

    <section class="canvasWrap">
      <canvas id="c"></canvas>
      <div id="overlay" class="overlay"></div>
    </section>
  </div>

<script>
(() => {
  // === UI ===
  const el = (id) => document.getElementById(id);
  const v0El = el('v0'), angEl = el('ang'), y0El = el('y0'), gEl = el('g'), dtEl = el('dt');
  const v0Label = el('v0Label'), angLabel = el('angLabel'), y0Label = el('y0Label'), gLabel = el('gLabel'), dtLabel = el('dtLabel');
  const statsEl = el('stats');
  const playBtn = el('playBtn'), resetBtn = el('resetBtn');
  const overlayEl = el('overlay');

  function updateLabels() {
    v0Label.textContent = Number(v0El.value).toFixed(1);
    angLabel.textContent = `${Number(angEl.value).toFixed(0)}¬∞`;
    y0Label.textContent = Number(y0El.value).toFixed(1);
    gLabel.textContent  = Number(gEl.value).toFixed(1);
    dtLabel.textContent = Number(dtEl.value).toFixed(3);
  }
  [v0El, angEl, y0El, gEl, dtEl].forEach(i => i.addEventListener('input', () => {
    updateLabels();
    recomputeAndRedraw();
  }));
  updateLabels();

  // === Canvas setup (HiDPI) ===
  const canvas = el('c');
  const ctx = canvas.getContext('2d');
  function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    // Ensure canvas has a measurable size before drawing
    if (!rect.width || !rect.height) return;
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width  = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
    recomputeAndRedraw();
  }
  window.addEventListener('resize', resizeCanvas);

  // Vector & target settings
  const margin = { l: 50, r: 20, t: 20, b: 50 };

  // Vector & target settings
  const vectorScale = 0.6; // pixels per (m/s) after world->screen scaling is applied
  const gravityVectorMeters = 6; // length of gravity arrow drawn (in meters, visual only)

  // Simple target (can be moved by clicking on the canvas)
  let target = {
    x: 20, // meters
    y: 5,  // meters
    r: 1.2 // meters (radius)
  };
  let hit = false;

  function degToRad(d) { return d * Math.PI / 180; }

  function computeAnalytic(v0, angDeg, y0, g) {
    const th = degToRad(angDeg);
    const v0x = v0 * Math.cos(th);
    const v0y = v0 * Math.sin(th);

    // Time to hit ground: solve y(t)=0 => y0 + v0y t - 1/2 g t^2 = 0
    // t = (v0y + sqrt(v0y^2 + 2 g y0)) / g  (positive root)
    const disc = v0y*v0y + 2*g*y0;
    const T = (v0y + Math.sqrt(Math.max(0, disc))) / g;

    const R = v0x * T;
    const H = y0 + (v0y*v0y) / (2*g); // max height above ground if y0 included
    return { v0x, v0y, T, R, H };
  }

  // === Simulation state ===
  let isPlaying = false;
  let t = 0;
  let pos = { x: 0, y: 0 };
  let vel = { x: 0, y: 0 };
  let trail = []; // sampled positions for drawing
  let lastTs = null;
  let accumulator = 0; // seconds accumulated for fixed-step simulation

  function resetSim() {
    const v0 = Number(v0El.value);
    const ang = Number(angEl.value);
    const y0 = Number(y0El.value);
    const g = Number(gEl.value);
    const th = degToRad(ang);

    t = 0;
    pos = { x: 0, y: y0 };
    vel = { x: v0 * Math.cos(th), y: v0 * Math.sin(th) };
    trail = [{ x: pos.x, y: pos.y }];
    lastTs = null;
    accumulator = 0;
    isPlaying = false;
    playBtn.textContent = 'Simular';
    hit = false;
    updateStats();
    draw();
  }

  function updateStats() {
    const v0 = Number(v0El.value);
    const ang = Number(angEl.value);
    const y0 = Number(y0El.value);
    const g = Number(gEl.value);
    const a = computeAnalytic(v0, ang, y0, g);

    statsEl.innerHTML = `
      <b>Resultados (modelo anal√≠tico)</b><br/>
      Tiempo de vuelo T ‚âà <b>${a.T.toFixed(2)} s</b><br/>
      Alcance R ‚âà <b>${a.R.toFixed(2)} m</b><br/>
      Altura m√°xima H ‚âà <b>${a.H.toFixed(2)} m</b><br/>
      <span style="opacity:.8">Estado simulaci√≥n: t=${t.toFixed(2)} s, x=${pos.x.toFixed(2)} m, y=${pos.y.toFixed(2)} m, vx=${vel.x.toFixed(2)} m/s, vy=${vel.y.toFixed(2)} m/s</span>
    `;
  }

  function recomputeAndRedraw() {
    if (!isPlaying) resetSim();
    else { updateStats(); draw(); }
  }

  // === Drawing helpers ===
  function clear() {
    ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
  }

  function drawGrid(worldMaxX, worldMaxY, toScreen) {
    const w = canvas.clientWidth, h = canvas.clientHeight;

    // Background
    ctx.fillStyle = '#070a0f';
    ctx.fillRect(0, 0, w, h);

    // axes & grid
    ctx.strokeStyle = 'rgba(255,255,255,0.10)';
    ctx.lineWidth = 1;

    // grid step based on range
    const stepX = niceStep(worldMaxX);
    const stepY = niceStep(worldMaxY);

    // vertical grid
    for (let x = 0; x <= worldMaxX + 1e-9; x += stepX) {
      const p = toScreen(x, 0);
      ctx.beginPath();
      ctx.moveTo(p.x, margin.t);
      ctx.lineTo(p.x, h - margin.b);
      ctx.stroke();
    }
    // horizontal grid
    for (let y = 0; y <= worldMaxY + 1e-9; y += stepY) {
      const p = toScreen(0, y);
      ctx.beginPath();
      ctx.moveTo(margin.l, p.y);
      ctx.lineTo(w - margin.r, p.y);
      ctx.stroke();
    }

    // axes
    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
    ctx.beginPath();
    // x-axis (ground)
    const g0 = toScreen(0, 0);
    ctx.moveTo(margin.l, g0.y);
    ctx.lineTo(w - margin.r, g0.y);
    ctx.stroke();

    ctx.beginPath();
    // y-axis at x=0
    ctx.moveTo(toScreen(0,0).x, margin.t);
    ctx.lineTo(toScreen(0,0).x, h - margin.b);
    ctx.stroke();

    // labels
    ctx.fillStyle = 'rgba(233,238,245,0.85)';
    ctx.font = '12px system-ui';
    ctx.fillText('x (m)', w - 50, h - 18);
    ctx.fillText('y (m)', 12, 18);
  }

  function niceStep(maxVal) {
    // choose 1,2,5 * 10^n
    if (maxVal <= 0) return 1;
    const rough = maxVal / 8;
    const p = Math.pow(10, Math.floor(Math.log10(rough)));
    const r = rough / p;
    const m = (r < 1.5) ? 1 : (r < 3.5) ? 2 : (r < 7.5) ? 5 : 10;
    return m * p;
  }
  function drawArrow(from, to, color = 'rgba(233,238,245,0.9)') {
    const headLen = 10;
    const dx = to.x - from.x;
    const dy = to.y - from.y;
    const ang = Math.atan2(dy, dx);

    ctx.strokeStyle = color;
    ctx.fillStyle = color;
    ctx.lineWidth = 2;

    ctx.beginPath();
    ctx.moveTo(from.x, from.y);
    ctx.lineTo(to.x, to.y);
    ctx.stroke();

    // arrow head
    ctx.beginPath();
    ctx.moveTo(to.x, to.y);
    ctx.lineTo(to.x - headLen * Math.cos(ang - Math.PI / 6), to.y - headLen * Math.sin(ang - Math.PI / 6));
    ctx.lineTo(to.x - headLen * Math.cos(ang + Math.PI / 6), to.y - headLen * Math.sin(ang + Math.PI / 6));
    ctx.closePath();
    ctx.fill();
  }

  function checkHit() {
    const dx = pos.x - target.x;
    const dy = pos.y - target.y;
    return (dx * dx + dy * dy) <= (target.r * target.r);
  }

  let lastView = null;
  let lastToScreen = null;

  function draw() {
    const v0 = Number(v0El.value);
    const ang = Number(angEl.value);
    const y0 = Number(y0El.value);
    const g = Number(gEl.value);
    const a = computeAnalytic(v0, ang, y0, g);

    // Determine world bounds (fit full trajectory)
    const worldMaxX = Math.max(10, a.R * 1.05);
    const worldMaxY = Math.max(5, a.H * 1.15);

    const w = canvas.clientWidth, h = canvas.clientHeight;
    const usableW = w - margin.l - margin.r;
    const usableH = h - margin.t - margin.b;

    const scaleX = usableW / worldMaxX;
    const scaleY = usableH / worldMaxY;
    const scale = Math.min(scaleX, scaleY);

    const toScreen = (x, y) => ({
      x: margin.l + x * scale,
      y: h - margin.b - y * scale
    });

    // Save for click mapping
    lastView = { scale, w, h };
    lastToScreen = toScreen;

    clear();
    drawGrid(worldMaxX, worldMaxY, toScreen);

    // Draw analytic curve (thin)
    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    const samples = 200;
    for (let i = 0; i <= samples; i++) {
      const tt = (a.T * i) / samples;
      const xx = a.v0x * tt;
      const yy = y0 + a.v0y * tt - 0.5 * g * tt * tt;
      const p = toScreen(xx, Math.max(0, yy));
      if (i === 0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();

    // Draw simulated trail (thicker)
    ctx.strokeStyle = 'rgba(31,111,235,0.95)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let i = 0; i < trail.length; i++) {
      const p = toScreen(trail[i].x, trail[i].y);
      if (i === 0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();

    // Draw projectile
    const p = toScreen(pos.x, Math.max(0, pos.y));
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.beginPath();
    ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
    ctx.fill();

    // Draw range marker
    const pr = toScreen(a.R, 0);
    ctx.fillStyle = 'rgba(233,238,245,0.85)';
    ctx.font = '12px system-ui';
    ctx.fillText(`R‚âà${a.R.toFixed(2)}m`, pr.x - 40, pr.y + 18);

    // Draw target
    const tp = toScreen(target.x, target.y);
    ctx.strokeStyle = hit ? 'rgba(110,231,183,0.95)' : 'rgba(251,191,36,0.95)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(tp.x, tp.y, target.r * scale, 0, Math.PI * 2);
    ctx.stroke();
    ctx.fillStyle = 'rgba(251,191,36,0.15)';
    ctx.beginPath();
    ctx.arc(tp.x, tp.y, target.r * scale, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = 'rgba(233,238,245,0.85)';
    ctx.font = '12px system-ui';
    ctx.fillText('Objetivo', tp.x - 24, tp.y - (target.r * scale) - 8);

    // Draw vectors at projectile position
    const pp = toScreen(pos.x, Math.max(0, pos.y));

    // Velocity vector (scaled)
    const vpx = pp.x + (vel.x * scale * vectorScale);
    const vpy = pp.y - (vel.y * scale * vectorScale); // minus because screen y is inverted
    drawArrow(pp, { x: vpx, y: vpy }, 'rgba(31,111,235,0.95)');

    // Gravity vector (down)
    const gEnd = toScreen(pos.x, Math.max(0, pos.y - gravityVectorMeters));
    drawArrow(pp, gEnd, 'rgba(248,113,113,0.95)');

    // Vector labels
    ctx.fillStyle = 'rgba(31,111,235,0.95)';
    ctx.fillText('v', vpx + 6, vpy);
    ctx.fillStyle = 'rgba(248,113,113,0.95)';
    ctx.fillText('g', gEnd.x + 6, gEnd.y);

    // Overlay with equations + live values
    const th = degToRad(ang);
    const v0x = v0 * Math.cos(th);
    const v0y = v0 * Math.sin(th);
    const eqX = `x(t) = x0 + v0¬∑cos(Œ∏)¬∑t`;
    const eqY = `y(t) = y0 + v0¬∑sin(Œ∏)¬∑t ‚àí ¬Ω¬∑g¬∑t¬≤`;
    const hitClass = hit ? 'ok' : 'warn';
    overlayEl.innerHTML = `
      <b>Ecuaciones</b><br/>
      ${eqX}<br/>
      ${eqY}<br/><br/>
      <b>Valores</b><br/>
      v0x=${v0x.toFixed(2)} m/s, v0y=${v0y.toFixed(2)} m/s<br/>
      t=${t.toFixed(2)} s, x=${pos.x.toFixed(2)} m, y=${pos.y.toFixed(2)} m<br/>
      vx=${vel.x.toFixed(2)} m/s, vy=${vel.y.toFixed(2)} m/s<br/>
      objetivo: (${target.x.toFixed(1)}, ${target.y.toFixed(1)}) r=${target.r.toFixed(1)} m<br/>
      <b class="${hitClass}">${hit ? '‚úÖ Impacto detectado' : 'üéØ Sin impacto (click en el canvas para mover el objetivo)'}</b>
    `;
  }

  // === Simulation loop (Euler integration) ===
  function step(dt) {
    const g = Number(gEl.value);

    // Integrate velocity then position (semi-implicit Euler)
    vel.y += -g * dt;
    pos.x += vel.x * dt;
    pos.y += vel.y * dt;

    t += dt;

    // Save trail occasionally (avoid huge arrays)
    if (trail.length === 0 || (trail.length > 0 && (t - (trail._lastT || 0)) >= 0.02)) {
      trail.push({ x: pos.x, y: Math.max(0, pos.y) });
      trail._lastT = t;
    }

    // Stop at ground
    if (pos.y <= 0) {
      pos.y = 0;
      isPlaying = false;
      playBtn.textContent = 'Simular';
    }
    if (!hit && checkHit()) {
      hit = true;
      isPlaying = false;
      playBtn.textContent = 'Simular';
    }
  }

  function loop(ts) {
    if (!isPlaying) return;

    // Initialize timing on first frame
    if (lastTs == null) {
      lastTs = ts;
      accumulator = 0;
    }

    const fixedDt = Number(dtEl.value);

    // Accumulate elapsed time (in seconds)
    const elapsed = (ts - lastTs) / 1000;
    lastTs = ts;

    // Guard against huge tab-switch jumps
    const clamped = Math.min(elapsed, 0.25);
    accumulator += clamped;

    // Step the simulation using a fixed time step for stability
    let steps = 0;
    const maxStepsPerFrame = 25;
    while (accumulator >= fixedDt && steps < maxStepsPerFrame) {
      step(fixedDt);
      accumulator -= fixedDt;
      steps++;
    }

    // Always redraw so the user sees changes immediately
    updateStats();
    draw();

    requestAnimationFrame(loop);
  }

  // === Buttons ===
  playBtn.addEventListener('click', () => {
    if (!isPlaying) {
      // Start or resume
      isPlaying = true;
      playBtn.textContent = 'Pausar';
      lastTs = null; // re-sync timing on resume
      requestAnimationFrame(loop);
    } else {
      // Pause
      isPlaying = false;
      playBtn.textContent = 'Simular';
    }
  });

  resetBtn.addEventListener('click', () => {
    resetSim();
  });

  canvas.addEventListener('click', (ev) => {
    if (!lastView) return;
    const rect = canvas.getBoundingClientRect();
    const cx = ev.clientX - rect.left;
    const cy = ev.clientY - rect.top;

    // Invert the current world->screen mapping
    const w = rect.width;
    const h = rect.height;

    // Recompute current scale using latest analytic bounds (mirrors draw())
    const v0 = Number(v0El.value);
    const ang = Number(angEl.value);
    const y0 = Number(y0El.value);
    const g = Number(gEl.value);
    const a = computeAnalytic(v0, ang, y0, g);

    const worldMaxX = Math.max(10, a.R * 1.05);
    const worldMaxY = Math.max(5, a.H * 1.15);

    const usableW = w - margin.l - margin.r;
    const usableH = h - margin.t - margin.b;

    const scaleX = usableW / worldMaxX;
    const scaleY = usableH / worldMaxY;
    const scale = Math.min(scaleX, scaleY);

    const wx = (cx - margin.l) / scale;
    const wy = (h - margin.b - cy) / scale;

    if (Number.isFinite(wx) && Number.isFinite(wy)) {
      target.x = Math.max(0, wx);
      target.y = Math.max(0, wy);
      hit = false;
      updateStats();
      draw();
    }
  });

  // init (after all state variables are initialized)
  resizeCanvas();
  resetSim();
})();
</script>
</body>
</html>